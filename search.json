[
  {
    "objectID": "core.html",
    "href": "core.html",
    "title": "core",
    "section": "",
    "text": "source\n\nfoo\n\n foo ()\n\n\nsource\n\n\nPerson\n\n Person (id:int, name:str, email:str, phone:str, met_ts:datetime.datetime)\n\nUsage docs: https://docs.pydantic.dev/2.5/concepts/models/\nA base class for creating Pydantic models.\nAttributes: class_vars: The names of classvars defined on the model. private_attributes: Metadata about the private attributes of the model. signature: The signature for instantiating the model.\n__pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n__pydantic_core_schema__: The pydantic-core schema used to build the SchemaValidator and SchemaSerializer.\n__pydantic_custom_init__: Whether the model has a custom `__init__` function.\n__pydantic_decorators__: Metadata containing the decorators defined on the model.\n    This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n__pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n    __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n__pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n__pydantic_post_init__: The name of the post-init method for the model, if defined.\n__pydantic_root_model__: Whether the model is a `RootModel`.\n__pydantic_serializer__: The pydantic-core SchemaSerializer used to dump instances of the model.\n__pydantic_validator__: The pydantic-core SchemaValidator used to validate instances of the model.\n\n__pydantic_extra__: An instance attribute with the values of extra fields from validation when\n    `model_config['extra'] == 'allow'`.\n__pydantic_fields_set__: An instance attribute with the names of fields explicitly set.\n__pydantic_private__: Instance attribute with the values of private attributes set on the model instance.\n\nPerson??\n\n\nInit signature:\nPerson(\n    *,\n    id: int,\n    name: str,\n    email: str,\n    phone: str,\n    met_ts: datetime.datetime,\n) -&gt; None\nDocstring:     \nUsage docs: https://docs.pydantic.dev/2.5/concepts/models/\nA base class for creating Pydantic models.\nAttributes:\n    __class_vars__: The names of classvars defined on the model.\n    __private_attributes__: Metadata about the private attributes of the model.\n    __signature__: The signature for instantiating the model.\n    __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n    __pydantic_core_schema__: The pydantic-core schema used to build the SchemaValidator and SchemaSerializer.\n    __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n    __pydantic_decorators__: Metadata containing the decorators defined on the model.\n        This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n    __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n        __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n    __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n    __pydantic_post_init__: The name of the post-init method for the model, if defined.\n    __pydantic_root_model__: Whether the model is a `RootModel`.\n    __pydantic_serializer__: The pydantic-core SchemaSerializer used to dump instances of the model.\n    __pydantic_validator__: The pydantic-core SchemaValidator used to validate instances of the model.\n    __pydantic_extra__: An instance attribute with the values of extra fields from validation when\n        `model_config['extra'] == 'allow'`.\n    __pydantic_fields_set__: An instance attribute with the names of fields explicitly set.\n    __pydantic_private__: Instance attribute with the values of private attributes set on the model instance.\nSource:        \n@dataclass_transform(kw_only_default=True, field_specifiers=(PydanticModelField,))\nclass ModelMetaclass(ABCMeta):\n    def __new__(\n        mcs,\n        cls_name: str,\n        bases: tuple[type[Any], ...],\n        namespace: dict[str, Any],\n        __pydantic_generic_metadata__: PydanticGenericMetadata | None = None,\n        __pydantic_reset_parent_namespace__: bool = True,\n        _create_model_module: str | None = None,\n        **kwargs: Any,\n    ) -&gt; type:\n        \"\"\"Metaclass for creating Pydantic models.\n        Args:\n            cls_name: The name of the class to be created.\n            bases: The base classes of the class to be created.\n            namespace: The attribute dictionary of the class to be created.\n            __pydantic_generic_metadata__: Metadata for generic models.\n            __pydantic_reset_parent_namespace__: Reset parent namespace.\n            _create_model_module: The module of the class to be created, if created by `create_model`.\n            **kwargs: Catch-all for any other keyword arguments.\n        Returns:\n            The new class created by the metaclass.\n        \"\"\"\n        # Note `ModelMetaclass` refers to `BaseModel`, but is also used to *create* `BaseModel`, so we rely on the fact\n        # that `BaseModel` itself won't have any bases, but any subclass of it will, to determine whether the `__new__`\n        # call we're in the middle of is for the `BaseModel` class.\n        if bases:\n            base_field_names, class_vars, base_private_attributes = mcs._collect_bases_data(bases)\n            config_wrapper = ConfigWrapper.for_model(bases, namespace, kwargs)\n            namespace['model_config'] = config_wrapper.config_dict\n            private_attributes = inspect_namespace(\n                namespace, config_wrapper.ignored_types, class_vars, base_field_names\n            )\n            if private_attributes:\n                original_model_post_init = get_model_post_init(namespace, bases)\n                if original_model_post_init is not None:\n                    # if there are private_attributes and a model_post_init function, we handle both\n                    def wrapped_model_post_init(self: BaseModel, __context: Any) -&gt; None:\n                        \"\"\"We need to both initialize private attributes and call the user-defined model_post_init\n                        method.\n                        \"\"\"\n                        init_private_attributes(self, __context)\n                        original_model_post_init(self, __context)\n                    namespace['model_post_init'] = wrapped_model_post_init\n                else:\n                    namespace['model_post_init'] = init_private_attributes\n            namespace['__class_vars__'] = class_vars\n            namespace['__private_attributes__'] = {**base_private_attributes, **private_attributes}\n            if config_wrapper.frozen:\n                set_default_hash_func(namespace, bases)\n            cls: type[BaseModel] = super().__new__(mcs, cls_name, bases, namespace, **kwargs)  # type: ignore\n            from ..main import BaseModel\n            mro = cls.__mro__\n            if Generic in mro and mro.index(Generic) &lt; mro.index(BaseModel):\n                warnings.warn(\n                    GenericBeforeBaseModelWarning(\n                        'Classes should inherit from `BaseModel` before generic classes (e.g. `typing.Generic[T]`) '\n                        'for pydantic generics to work properly.'\n                    ),\n                    stacklevel=2,\n                )\n            cls.__pydantic_custom_init__ = not getattr(cls.__init__, '__pydantic_base_init__', False)\n            cls.__pydantic_post_init__ = None if cls.model_post_init is BaseModel.model_post_init else 'model_post_init'\n            cls.__pydantic_decorators__ = DecoratorInfos.build(cls)\n            # Use the getattr below to grab the __parameters__ from the `typing.Generic` parent class\n            if __pydantic_generic_metadata__:\n                cls.__pydantic_generic_metadata__ = __pydantic_generic_metadata__\n            else:\n                parent_parameters = getattr(cls, '__pydantic_generic_metadata__', {}).get('parameters', ())\n                parameters = getattr(cls, '__parameters__', None) or parent_parameters\n                if parameters and parent_parameters and not all(x in parameters for x in parent_parameters):\n                    combined_parameters = parent_parameters + tuple(x for x in parameters if x not in parent_parameters)\n                    parameters_str = ', '.join([str(x) for x in combined_parameters])\n                    generic_type_label = f'typing.Generic[{parameters_str}]'\n                    error_message = (\n                        f'All parameters must be present on typing.Generic;'\n                        f' you should inherit from {generic_type_label}.'\n                    )\n                    if Generic not in bases:  # pragma: no cover\n                        # We raise an error here not because it is desirable, but because some cases are mishandled.\n                        # It would be nice to remove this error and still have things behave as expected, it's just\n                        # challenging because we are using a custom `__class_getitem__` to parametrize generic models,\n                        # and not returning a typing._GenericAlias from it.\n                        bases_str = ', '.join([x.__name__ for x in bases] + [generic_type_label])\n                        error_message += (\n                            f' Note: `typing.Generic` must go last: `class {cls.__name__}({bases_str}): ...`)'\n                        )\n                    raise TypeError(error_message)\n                cls.__pydantic_generic_metadata__ = {\n                    'origin': None,\n                    'args': (),\n                    'parameters': parameters,\n                }\n            cls.__pydantic_complete__ = False  # Ensure this specific class gets completed\n            # preserve `__set_name__` protocol defined in https://peps.python.org/pep-0487\n            # for attributes not in `new_namespace` (e.g. private attributes)\n            for name, obj in private_attributes.items():\n                obj.__set_name__(cls, name)\n            if __pydantic_reset_parent_namespace__:\n                cls.__pydantic_parent_namespace__ = build_lenient_weakvaluedict(parent_frame_namespace())\n            parent_namespace = getattr(cls, '__pydantic_parent_namespace__', None)\n            if isinstance(parent_namespace, dict):\n                parent_namespace = unpack_lenient_weakvaluedict(parent_namespace)\n            types_namespace = get_cls_types_namespace(cls, parent_namespace)\n            set_model_fields(cls, bases, config_wrapper, types_namespace)\n            complete_model_class(\n                cls,\n                cls_name,\n                config_wrapper,\n                raise_errors=False,\n                types_namespace=types_namespace,\n                create_model_module=_create_model_module,\n            )\n            # using super(cls, cls) on the next line ensures we only call the parent class's __pydantic_init_subclass__\n            # I believe the `type: ignore` is only necessary because mypy doesn't realize that this code branch is\n            # only hit for _proper_ subclasses of BaseModel\n            super(cls, cls).__pydantic_init_subclass__(**kwargs)  # type: ignore[misc]\n            return cls\n        else:\n            # this is the BaseModel class itself being created, no logic required\n            return super().__new__(mcs, cls_name, bases, namespace, **kwargs)\n    if not typing.TYPE_CHECKING:  # pragma: no branch\n        # We put `__getattr__` in a non-TYPE_CHECKING block because otherwise, mypy allows arbitrary attribute access\n        def __getattr__(self, item: str) -&gt; Any:\n            \"\"\"This is necessary to keep attribute access working for class attribute access.\"\"\"\n            private_attributes = self.__dict__.get('__private_attributes__')\n            if private_attributes and item in private_attributes:\n                return private_attributes[item]\n            if item == '__pydantic_core_schema__':\n                # This means the class didn't get a schema generated for it, likely because there was an undefined reference\n                maybe_mock_validator = getattr(self, '__pydantic_validator__', None)\n                if isinstance(maybe_mock_validator, MockValSer):\n                    rebuilt_validator = maybe_mock_validator.rebuild()\n                    if rebuilt_validator is not None:\n                        # In this case, a validator was built, and so `__pydantic_core_schema__` should now be set\n                        return getattr(self, '__pydantic_core_schema__')\n            raise AttributeError(item)\n    @classmethod\n    def __prepare__(cls, *args: Any, **kwargs: Any) -&gt; Mapping[str, object]:\n        return _ModelNamespaceDict()\n    def __instancecheck__(self, instance: Any) -&gt; bool:\n        \"\"\"Avoid calling ABC _abc_subclasscheck unless we're pretty sure.\n        See #3829 and python/cpython#92810\n        \"\"\"\n        return hasattr(instance, '__pydantic_validator__') and super().__instancecheck__(instance)\n    @staticmethod\n    def _collect_bases_data(bases: tuple[type[Any], ...]) -&gt; tuple[set[str], set[str], dict[str, ModelPrivateAttr]]:\n        from ..main import BaseModel\n        field_names: set[str] = set()\n        class_vars: set[str] = set()\n        private_attributes: dict[str, ModelPrivateAttr] = {}\n        for base in bases:\n            if issubclass(base, BaseModel) and base is not BaseModel:\n                # model_fields might not be defined yet in the case of generics, so we use getattr here:\n                field_names.update(getattr(base, 'model_fields', {}).keys())\n                class_vars.update(base.__class_vars__)\n                private_attributes.update(base.__private_attributes__)\n        return field_names, class_vars, private_attributes\n    @property\n    @deprecated(\n        'The `__fields__` attribute is deprecated, use `model_fields` instead.', category=PydanticDeprecatedSince20\n    )\n    def __fields__(self) -&gt; dict[str, FieldInfo]:\n        warnings.warn('The `__fields__` attribute is deprecated, use `model_fields` instead.', DeprecationWarning)\n        return self.model_fields  # type: ignore\nFile:           ~/.pyenv/versions/3.9.18/envs/nbdev39/lib/python3.9/site-packages/pydantic/_internal/_model_construction.py\nType:           ModelMetaclass\nSubclasses:     \n\n\n\nThis is my first unit test:\n\nassert 1==1"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "chrphb-contacts",
    "section": "",
    "text": "This file will become your README and also the index of your documentation."
  },
  {
    "objectID": "index.html#install",
    "href": "index.html#install",
    "title": "chrphb-contacts",
    "section": "Install",
    "text": "Install\npip install chrphb_contacts"
  },
  {
    "objectID": "index.html#how-to-use",
    "href": "index.html#how-to-use",
    "title": "chrphb-contacts",
    "section": "How to use",
    "text": "How to use\nFill me in please! Don’t forget code examples:\n\nexternal_data = {\n    'id': 1,\n    'name': 'John Doe',\n    'email': 'john@doe.com',\n    'phone': '00000000000',\n    'met_ts': '2019-06-01 12:22'\n}\n\nperson = Person(**external_data)\n\nperson.name\n\n'John Doe'\n\n\n\nfoo??\n\n\n1+1\n\n2"
  }
]